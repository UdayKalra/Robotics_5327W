#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    potlift,        sensorNone)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, in3,    potclaw,        sensorPotentiometer)
#pragma config(Sensor, dgtl2,  ,               sensorDigitalOut)
#pragma config(Sensor, dgtl3,  right1,         sensorNone)
#pragma config(Sensor, dgtl4,  solenoid,       sensorDigitalOut)
#pragma config(Sensor, dgtl8,  quadL,          sensorQuadEncoder)
#pragma config(Sensor, dgtl10, quadR,          sensorQuadEncoder)
#pragma config(Sensor, dgtl12, butt,           sensorTouch)
#pragma config(Motor,  port1,           lights,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           Lift1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           Lift2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rBase2,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           lBase2,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           Lift3,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           intake,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           rBase,         tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           lBase,         tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port10,           ,             tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// LCD Tresh

// Include the lcd button get utility function
#include "getlcdbuttons.c"

// global hold the auton selection
static int MyAutonomous = 0;


#define MOTOR_NUM               kNumbOfTotalMotors
#define MOTOR_MAX_VALUE         127
#define MOTOR_MIN_VALUE         (-127)
#define MOTOR_DEFAULT_SLEW_RATE 10      // Default will cause 375mS from full fwd to rev
#define MOTOR_FAST_SLEW_RATE    256     // essentially off
#define MOTOR_TASK_DELAY        15      // task 1/frequency in mS (about 66Hz)
#define MOTOR_DEADBAND          10
#define MAX_CHOICE  3
// Array to hold requested speed for the motors
int motorReq[ MOTOR_NUM ];

// Array to hold "slew rate" for the motors, the maximum change every time the task
// runs checking current mootor speed.
int motorSlew[ MOTOR_NUM ];
// This code is for the VEX cortex platform
#pragma platform(VEX2)


// Select Download method as "competition"
#pragma competitionControl(Competition)py
#define     JOY_DRIVE_V     vexJSLeftV
#define     JOY_DRIVE_H     vexJSLeftH
#define     JOY_THRESHOLD   15
//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
#include "gyroLib2.c"
#define PID_INTEGRAL_LIMIT  50
int Program;
/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/
static float  pid_Kp = 0.05;
static float  pid_Ki = 0.0;
static float  pid_Kd = 0.01;
float  pidSensorCurrentValue;
static float  pidRequestedValue;
static float  pidError;
static float  pidDrive;
static double turnTicks = 1;
int topLim = 3100;
int lowLim = 100;
static float x;
int polarity = 1;
int claw = -1;
int pidd = 2;
int z = 0;
int max = 127;
static float pcv;
static float pcr;
int e = 0;
static float ga;
static int rpid = 0;
static int lpid = 0;

task pidController()
{

	float  pidError;
	float  pidLastError;
	float  pidIntegral;
	float  pidDerivative;
	float  pidDrive;



	pidLastError  = 0;
	while( 1==1 )
	{
		if(z==1){
			// Read the sensor value and scale
			pidSensorCurrentValue = (4095 - SensorValue[potlift]);

			// calculate error
			pidError =  pidRequestedValue - pidSensorCurrentValue;
			if( pid_Ki != 0 )
			{
				// If we are inside controlable window then integrate the error
				if( abs(pidError) < PID_INTEGRAL_LIMIT )
					pidIntegral = pidIntegral + pidError;
				else
					pidIntegral = 0;
			}
			else{
				pidIntegral = 0; }

			// calculate the derivative
			pidDerivative = pidError - pidLastError;
			pidLastError  = pidError;

			// calculate drive
			pidDrive = (pid_Kp * pidError)+ (pid_Ki * pidIntegral) + (pid_Kd * pidDerivative);


			// limit drive
			if( pidDrive > 127 )
				pidDrive = 127;
			if( pidDrive < (-127) )
				pidDrive = (-127);

			// send to motor
			motor[Lift1] = pidDrive;
			motor[Lift2] = pidDrive;
			motor[Lift3] = pidDrive;

			// Don't hog cpu
			wait1Msec(4);
		}
	}

}
task MotorSlewRateTask()
{
    int motorIndex;
    int motorTmp;

    // Initialize stuff
    for(motorIndex=0;motorIndex<MOTOR_NUM;motorIndex++)
        {
        motorReq[motorIndex] = 0;
        motorSlew[motorIndex] = MOTOR_DEFAULT_SLEW_RATE;
        }

    // run task until stopped
    while( true )
        {
        // run loop for every motor
        for( motorIndex=0; motorIndex<MOTOR_NUM; motorIndex++)
            {
            	if(motorIndex!=1 && motorIndex!=2 && motorIndex!=3 && motorIndex!=6 &&motorIndex!=7 &&motorIndex!=10){
            // So we don't keep accessing the internal storage
            motorTmp = motor[ motorIndex ];

            // Do we need to change the motor value ?
            if( motorTmp != motorReq[motorIndex] )
                {
                // increasing motor value
                if( motorReq[motorIndex] > motorTmp )
                    {
                    motorTmp += motorSlew[motorIndex];
                    // limit
                    if( motorTmp > motorReq[motorIndex] )
                        motorTmp = motorReq[motorIndex];
                    }

                // decreasing motor value
                if( motorReq[motorIndex] < motorTmp )
                    {
                    motorTmp -= motorSlew[motorIndex];
                    // limit
                    if( motorTmp < motorReq[motorIndex] )
                        motorTmp = motorReq[motorIndex];
                    }

                // finally set motor
                motor[motorIndex] = motorTmp;
                }
              }
            }

        // Wait approx the speed of motor update over the spi bus
        wait1Msec( MOTOR_TASK_DELAY );
        }
}
void DriveLeftMotor( int value )
{
    motorReq[lBase] = value;
    motorReq[ lBase2 ] = value;
}

void DriveRightMotor( int value )
{
    motorReq[ rBase ] = value;
    motorReq[ rBase2 ] = value;
}

int speedSwag(int orSpeed){
	int modSpeed = 0;
	if (orSpeed >= 0) {
		modSpeed = (orSpeed * orSpeed) / 127;
		} else {
		modSpeed = (orSpeed * orSpeed) / -127;
	}
	return modSpeed;
}
void recorder(){
	int ltarg = 0;
	int rtarg = 0;
	int liftarg = pidSensorCurrentValue;
	int clawtarg = pcv;
	SensorValue(quadL) = 0;
	SensorValue(quadR) = 0;
	playSound(soundBlip);
	writeDebugStreamLine("");
for(int i =0; i<149; i++){
	ltarg = SensorValue(quadL);
	rtarg = SensorValue(quadR);
	liftarg = pidSensorCurrentValue;
	clawtarg = pcv;
	writeDebugStreamLine("lpid = %i;", ltarg);
	writeDebugStreamLine("rpid = %i;", rtarg);
	writeDebugStreamLine("pidRequestedValue = %i;", liftarg);
	writeDebugStreamLine("pcr = %i;", clawtarg);
	writeDebugStreamLine("delay(100);");
	delay(100);
}
	playSound(soundBlip);
}
task pidBase(){
	static int lerr = 0;
	static int rerr = 0;
	static int  rval;
	static int lval;
	int ldrive = 0;
	int rdrive = 0;
	int kPb = 2;
	while(true){
		rval = SensorValue(quadR);
		lval = SensorValue(quadL);

		lerr = lval - lpid;
		rerr = rval - rpid;

		ldrive = lerr*kPb;
		rdrive = rerr*kPb;

		if(ldrive > 127){
			ldrive = 127;
		} else if(ldrive < -127){
		ldrive = -127;
		}

		if(rdrive > 127){
			rdrive = 127;
		} else if(rdrive < -127){
		rdrive = -127;
		}

		motor[rBase] = rdrive;
		motor[lBase2] = ldrive;
		motor[rBase2] = rdrive;
		motor[lBase] = ldrive;
	}
}

task TankDrive()
{
	int leftj;
	int rightj;
	while(1){
		leftj = speedSwag(VexRT[ch3]);
		rightj = speedSwag(VexRT[ch2]);
		motor[lBase2] = motor[lBase] = leftj;
		motor[rBase2] = motor[rBase] = rightj;
	    }
}

task pidclaw()
{
	int clawError;
	int clawVal;
	int c = 1;
	while(1==1){
		pcv = SensorValue(potclaw);
		if(vexRT[Btn6U] == 1){
			motor[intake] = 127;
			c=1;
			} else if(vexRT[Btn6D] == 1){
			motor[intake] = - 127;
			c=1;
		}
		else if( vexRT[Btn6U] == 0 && vexRT[Btn6D] == 0 && c == 1){
			if (pcv >= 4095){
				pcr = 4095;
			}
			else if (pcv <= 0){
				pcr = 0;
			}
			else{

				pcr = pcv;
			}

			c = 0;
		}

		if (c==0){
		clawError =  pcr - pcv;
			clawVal = (clawError*0.3);
			motor[intake] = -clawVal;
			wait1Msec(5);
		}
	}
}

void forward(int speed, double time){
	int i = 0;
	time = time * 35714;
	while(i <= time){

		motor[lBase] = speed;
		motor[rBase] = speed;
		motor[lBase2] = speed;
		motor[rBase2] = speed;
		//wait1msec(1);
		i++;
	}
	motor[lBase] = 0;
	motor[rBase] = 0;
	motor[lBase2] = 0;
	motor[rBase2] = 0;
}
void driveForDist(int speed)
{
	motor[lBase] = speed;
	motor[rBase] = speed;
	motor[lBase2] = speed;
	motor[rBase2] = speed;
}
void driveDist(int speed, double dist)
{
	SensorValue(quadR) = 0;
	double ticks = dist / (3.25* PI) * 360 * 0.67;
	while(abs(SensorValue(quadR)) < ticks * .6)
	{
		driveforDist(speed);
	}
	while(abs(SensorValue(quadR)) < ticks )
	{
		driveforDist(speed/3);
	}

	driveforDist(0);
}
void turnu(int speed, double time)
{
	int i = 0;
	time = time * 35714;
	speed = speed * polarity;
	while(i <= time){
		motor[lBase] = -speed;
		motor[rBase] = speed;
		motor[lBase2] = -speed;
		motor[rBase2] = speed;
		//wait1msec(1);
		i++;
	}
}

void turnang(int speed, float angle){
	int m = 0;
   while(m==0)
        {
        if( GyroValidGet() ) {
            ga = GyroAngleDegGet();

            if( ga < angle ) {
                motor[lBase] = -speed;
		motor[rBase] = speed;
		motor[lBase2] = -speed;
		motor[rBase2] = speed;
            }
            if( ga > angle ) {
                motor[lBase] = -0;
		motor[rBase] = 0;
		motor[lBase2] = -0;
		motor[rBase2] = 0;
		m=1;
            }
        }

        wait1Msec(20);
        }
}

void turnDegree(int speed, int degree)
{
	SensorValue(quadL) = 0;
	SensorValue(quadR) = 0;
	int ticks = degree * turnTicks;
	while(abs(SensorValue(quadL)) < ticks)
	{
		int rDiff = abs(SensorValue(quadL)) - abs(SensorValue(quadR));
		int rMod = sgn(rDiff) * speed * 0.1;

		motor[rBase] = -speed - rMod;
		motor[lBase] = speed;
		motor[rBase2] = -speed - rMod;
		motor[lBase2] = speed;
	}
	while(abs(SensorValue(quadL)) < ticks)
	{
		int rDiff = abs(SensorValue(quadL)) - abs(SensorValue(quadR));
		int rMod = sgn(rDiff) * speed * 0.1;
		motor[rBase] = -speed * 0.8 - rMod;
		motor[lBase] = speed * 0.8;
		motor[rBase2] = -speed * 0.8 - rMod;
		motor[lBase2] = speed * 0.8;
	}
	turnu(-speed, 0.2);
	turnu(0, 0.2);

}



void lift(int speed, double time){
	int i = 0;
	time = time * 35714;
	while(i <= time){
		if(speed>0){
			if(SensorValue(potlift)<2450){
				motor[Lift1] = speed;
				motor[Lift2] = speed;
				motor[Lift3] = speed;
				}else{
				i = time;
			}
		}
		else if(speed<0){
			if(SensorValue(potlift)>0){
				motor[Lift1] = speed;
				motor[Lift2] = speed;
				motor[Lift3] = speed;
			}
			else{ i = time; }

		}
		//wait1msec(1);
		i++;
	}


	motor[Lift1] = 0;
	motor[Lift2] = 0;
	motor[Lift3] = 0;
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
void debug(){
	while(true){
		clearLCDLine(0);
		clearLCDLine(1);
		wait1Msec(200);

		displayLCDPos(0, 0);
		displayNextLCDString("Pot: ");
		displayLCDPos(0, 7);
		displayNextLCDNumber(SensorValue[potlift], 4);
		if(vexRT[Btn8L] == 1) //Left Shoulder Lift Up
		{
			break;
		}
	}
}

void off(){
	motor[lBase] = 0;
	motor[rBase] = 0;
	motor[lBase2] = 0;
	motor[rBase2] = 0;

	motor[intake] = 0;

	motor[Lift1] = 0;
	motor[Lift2] = 0;
	motor[Lift3] = 0;


}
void intak(int speed, double time){
	int i = 0;
	time = time * 35714;
	while(i <= time){
		motor[intake] = speed;
		//wait1msec(1);
		i++;
	}
	motor[intake] = 0;
}
void turnLeft(int speed, double time){
	int i = 0;
	time = time * 35714;
	speed = speed * polarity;
	while(i <= time){
		motor[lBase] = -speed;
		motor[rBase] = speed;
		motor[lBase2] = -speed;
		motor[rBase2] = speed;
		//wait1msec(1);
		i++;
	}
	motor[lBase] = 0;
	motor[rBase] = 0;
	motor[lBase2] = 0;
	motor[rBase2] = 0;
}

void turnRight(int speed, double time){
	int i = 0;
	time = time * 35714;
	speed = speed * polarity;
	while(i <= time){
		motor[rBase2] = -speed;
		motor[lBase] = speed;
		motor[rBase] = -speed;
		motor[lBase2] = speed;
		//wait1msec(1);
		i++;
	}
	motor[lBase] = 0;
	motor[rBase] = 0;
	motor[lBase2] = 0;
	motor[rBase2] = 0;
}
void leftStar(){
		pid_Kp = 0.075;
		z=1;
forward(-127, 0.4);
	pcr = 750;
	pidRequestedValue = 0;
	wait1Msec(800);
	turnLeft(-80, 0.2);
	pidRequestedValue = 0;
	forward(127, 0.3);
	pcr = 0;
	wait1Msec(1200);

forward(127, 0.2);
	pidRequestedValue = 1000;
	forward(-127, 0.2);
turnLeft(80, 0.1);
forward(-127, 1);
	pidRequestedValue = 2800;
	wait1Msec(800);
	pcr = 1000;
		wait1Msec(800);
	pcr = 0;
pid_kp = 0.05;
}
void rightStar(){
		pid_Kp = 0.075;
		z=1;
forward(-127, 0.4);
	pcr = 750;
	pidRequestedValue = 0;
	wait1Msec(800);
	turnLeft(80, 0.2);
	pidRequestedValue = 0;
	forward(127, 0.3);
	pcr = 0;
	wait1Msec(1200);

forward(127, 0.2);
	pidRequestedValue = 1000;
	forward(-127, 0.2);
turnLeft(-80, 0.1);
forward(-127, 1);
	pidRequestedValue = 2800;
	wait1Msec(800);
	pcr = 1000;
		wait1Msec(800);
	pcr = 0;
pid_kp = 0.05;
}
void eight(){
		 pid_Kp = 0.075;
	z=1;
	pidRequestedValue = 0;
	forward(-127, 1.2);
	pcr = 0;
	wait1Msec(800);
	pidRequestedValue = 2800;
	wait1Msec(800);
	pcr = 1500;
	wait1Msec(800);
	forward(-127, 0.1)
	forward(127, 0.3);
	pidRequestedValue = 1000;
	wait1Msec(800);
	pid_Kp = 0.05;
}
void hang(){
	 pid_Kp = 0.075
	z=1;
		pidRequestedValue = 0;
	forward(-127, 0.4);
	pcr = 750;
	pidRequestedValue = 0;
	wait1Msec(800);
	turnLeft(80, 0.15);
	pidRequestedValue = 0;
	forward(127, 0.4);
	pcr = 0;
	wait1Msec(1200);

forward(127, 0.2);
	pidRequestedValue = 1000;
	forward(-127, 0.4);
	pcr = 1000;
		wait1Msec(800);
		forward(127, 0.2);
		turnLeft(-80, 0.5);
	forward(-127, 1.1);
	pidRequestedValue = 3200;
	forward(-127, 0.7);
	forward(127, 0.3);
	pidRequestedValue = 3200;
	forward(127, 0.3);
	z = 0;
	pcr = 3000;
	lift(-127, 3);
	z = 1;
	pidRequestedValue = 0;
 pid_Kp = 0.05;

}
void auton(){
	/* forward is forward and backward */
	/*pcr=pid for claw, 0=closed, 4095=completly open*/
	/*pid requested value; 0=lift bottom  ; 2800 is top of lift*/
	/*pcr and pid run alongside funciton below */



	/**
	pidRequestedValue = 0;
	forward(-127, 0.4);
	pcr = 750;
	pidRequestedValue = 0;
	wait1Msec(800);
	turnLeft(80, 0.2);
	pidRequestedValue = 0;
	forward(127, 0.3);
	pcr = 0;
	wait1Msec(1200);

forward(127, 0.2);
	pidRequestedValue = 1000;
	forward(-127, 0.2);
turnLeft(-80, 0.15);
forward(-127, 1);
	pidRequestedValue = 2800;
	wait1Msec(800);
	pcr = 1000;
		wait1Msec(800);
		pidRequestedValue = 1000;
		wait1Msec(800);
		forward(127, 0.2);
		turnLeft(-80, 0.6);
	forward(-127, 1.1);
	pidRequestedValue = 3200;
	forward(-127, 0.7);
	forward(127, 0.3);
	pidRequestedValue = 3200;
	forward(127, 0.3);
	z = 0;
	pcr = 3000;
	lift(-127, 3);
	z = 1;
	pidRequestedValue = 0;

	 **/


	/**
	forward(-127, 0.4);
	pcr = 750;
	pidRequestedValue = 0;
	wait1Msec(800);
	turnLeft(80, 0.2);
	pidRequestedValue = 0;
	forward(127, 0.3);
	pcr = 0;
	wait1Msec(1200);

forward(127, 0.2);
	pidRequestedValue = 1000;
	forward(-127, 0.2);
turnLeft(-80, 0.1);
forward(-127, 1);
	pidRequestedValue = 2800;
	wait1Msec(800);
	pcr = 1000;
		wait1Msec(800);
	pcr = 0; **/

	}
	/**
	driveDist(-80, 28);
	turnDegree(-60, 35);
	driveDist(80, 45);
	close();
	wait1Msec(400);
	pidRequestedValue = 900;
	wait1Msec(800);
	turnDegree(60, 35);
	pidRequestedValue = 2100;
	driveDist(-127, 20);
	open();
	wait1Msec(400);
	pidRequestedValue = 0;
	wait1Msec(2000);
	driveDist(80, 30);
	close();
	wait1Msec(500);
	driveDist(-80, 10);
	pidRequestedValue = 900;
	driveDist(-127, 35);
	pidRequestedValue = 2100;
	wait1Msec(400);
	**/
	//	forward(-127, 0.4)
	//	open();
	//	wait1Msec(400);
	/*	pidRequestedValue = 1300;
	wait1Msec(400);
	pidRequestedValue = 0;
	wait1Msec(200);
	pidRequestedValue = 0;
	forward(127, 1.3)
	forward(-127, 0.9)
	turnLeft(127, 0.14)
	forward(127, 1.6);
	close();
	wait1Msec(400);
	pidRequestedValue = 900;
	wait1Msec(800);
	turnRight(127, 0.5)
	pidRequestedValue = 2100;
	forward(-127, 1);
	open();
	wait1Msec(400);
	pidRequestedValue=0;
	wait1Msec(2000);
	forward(127, 1);
	close();
	wait1Msec(500);
	forward(-127, 0.2);
	pidRequestedValue = 900;
	forward(-127, 0.7);
	pidRequestedValue = 2100;
	wait1Msec(400);
	open();*/
	/**
	driveDist(-80, 28);
	turnDegree(-60, 35);
	driveDist(80, 45);
	close();
	wait1Msec(400);
	pidRequestedValue = 900;
	wait1Msec(800);
	turnDegree(60, 35);
	pidRequestedValue = 2100;
	driveDist(-127, 20);
	open();
	wait1Msec(400);
	pidRequestedValue = 0;
	wait1Msec(2000);
	driveDist(80, 30);
	close();
	wait1Msec(500);
	driveDist(-80, 10);
	pidRequestedValue = 900;
	driveDist(-127, 35);
	pidRequestedValue = 2100;
	wait1Msec(400);
	**/
	//	forward(-127, 0.4)
	//	open();
	//	wait1Msec(400);
	/*	pidRequestedValue = 1300;
	wait1Msec(400);
	pidRequestedValue = 0;
	wait1Msec(200);
	pidRequestedValue = 0;
	forward(127, 1.3)
	forward(-127, 0.9)
	turnLeft(127, 0.14)
	forward(127, 1.6);
	close();
	wait1Msec(400);
	pidRequestedValue = 900;
	wait1Msec(800);
	turnRight(127, 0.5)
	pidRequestedValue = 2100;
	forward(-127, 1);
	open();
	wait1Msec(400);
	pidRequestedValue=0;
	wait1Msec(2000);
	forward(127, 1);
	close();
	wait1Msec(500);
	forward(-127, 0.2);
	pidRequestedValue = 900;
	forward(-127, 0.7);
	pidRequestedValue = 2100;
	wait1Msec(400);
	open();*/






void rerun(){
	z=1;
	SensorValue(quadL) = 0;
	SensorValue(quadR) = 0;


/*
How to Use:
When controller is plugged into comp, download program till debugger window appears
Press Start and go to Robot>Debugger Windows> Debug stream
Once the debug stream window appears, press 7D and drive for 15 seconds.
Once the stream stops recording(approx 15 seconds), copy all from debug stream directly below this multi-line comment.
Redownload the program and press 8L to Run.
*/
//Code Goes Directly below this line

}

void polchange(){
	wait1Msec(1000);
	polarity = polarity * -1;
	wait1Msec(1000);
}

task we(){
	playSoundFile("one.wav");
	wait10Msec(10);
	stopTask(we);

}




task liftrip(){
	int drm;
	while(1==1){
	if(e==1){
		if(sensorValue[butt] == 1){

		motor[Lift1] = -15;
			motor[Lift2] = -15;
			motor[Lift3] = -15;
		}
		else if (sensorValue[butt] == 0){
			motor[Lift1] = -80;
			motor[Lift2] = -80;
			motor[Lift3] =-80;
		}
	}
}
}
task liftGo(){
	while(1==1){
			if (pidd == 1){
			if(vexRT[Btn5U] == 1) //Left Shoulder Lift Up
			{

				motor[Lift1] = 127;
				motor[Lift2] = 127;
				motor[Lift3] = 127;
			} else if(vexRT[Btn5D] == 1) // Right Shoulder Lift Down
			{

				motor[Lift1] = -127;
				motor[Lift2] = -127;
				motor[Lift3] = -127;
			}
			else{
				motor[Lift1] = 0;
				motor[Lift2] = 0;
				motor[Lift3] = 0;
			}

			} else if (pidd == 2){
			if(vexRT[Btn5U] == 1 )
			{
				e = 0;
				z = 0;
				/**pidRequestedValue = pidRequestedValue + 30;
				// crude limiting to upper and lower values
				if( pidRequestedValue > topLim)
				pidRequestedValue = topLim;
				**/
				motor[Lift1] = max;
				motor[Lift2] = max;
				motor[Lift3] = max;
//playSound(soundFastUpwardTones);

			}
			else if(vexRT[Btn5D] == 1 )
			{
				/** pidRequestedValue = pidRequestedValue - 30;

				// crude limiting to upper and lower values
				if( pidRequestedValue < lowLim )
				pidRequestedValue = lowLim;
				**/
				z = 0;
				motor[Lift1] = -max;
				motor[Lift2] = -max;
				motor[Lift3] = -max;
				//playSound(soundDownwardTones);


			}
			else if(vexRT[Btn5D] == 0 && vexRT[Btn5U] == 0 && z == 0 && e == 0){

				if (pidSensorCurrentValue >= topLim){
					pidRequestedValue = topLim;
					z = 1;
				}
				else if (pidSensorCurrentValue <= lowLim){
					pidRequestedValue = lowLim;
					z = 1;
				}
				else{

					pidRequestedValue = pidSensorCurrentValue;
					z = 1;
				}



			}

		}
}
}



void
LcdAutonomousSet( int value, bool select = false )
{
    // Cleat the lcd
    clearLCDLine(0);
    clearLCDLine(1);

    // Display the selection arrows
    displayLCDString(1,  0, l_arr_str);
    displayLCDString(1, 13, r_arr_str);

    // Save autonomous mode for later if selected
    if(select)
        MyAutonomous = value;

    // If this choice is selected then display ACTIVE
    if( MyAutonomous == value )
        displayLCDString(1, 5, "ACTIVE");
    else
        displayLCDString(1, 5, "select");

    // Show the autonomous names
    switch(value) {
        case    0:
            displayLCDString(0, 0, "Left Star");
            break;
        case    1:
            displayLCDString(0, 0, "Right Star");
            break;
        case    2:
            displayLCDString(0, 0, "8K");
            break;
        case    3:
            displayLCDString(0, 0, "HangR");
            break;
        default:
            displayLCDString(0, 0, "Unknown");
            break;
        }
}
void
LcdAutonomousSelection()
{
    TControllerButtons  button;
    int  choice = 0;

    // Turn on backlight
    bLCDBacklight = true;

    // diaplay default choice
    LcdAutonomousSet(0);

    while( bIfiRobotDisabled )
        {
        // this function blocks until button is pressed
        button = getLcdButtons();

        // Display and select the autonomous routine
        if( ( button == kButtonLeft ) || ( button == kButtonRight ) ) {
            // previous choice
            if( button == kButtonLeft )
                if( --choice < 0 ) choice = MAX_CHOICE;
            // next choice
            if( button == kButtonRight )
                if( ++choice > MAX_CHOICE ) choice = 0;
            LcdAutonomousSet(choice);
            }

        // Select this choice
        if( button == kButtonCenter )
            LcdAutonomousSet(choice, true );

        // Don't hog the cpu !
        wait1Msec(10);
        }
}
void pre_auton()
{
    bStopTasksBetweenModes = true;

    LcdAutonomousSelection();
}
task autonomous()
{
	startTask(pidController);
switch( MyAutonomous ) {
        case    0:
            	startTask(pidclaw);

	stopTask(TankDrive);
		stopTask(liftGo);
	leftStar();
		e = 0;
		startTask(TankDrive);
		startTask(liftGo);
            break;

        case    1:
            	startTask(pidclaw);
	stopTask(TankDrive);
		stopTask(liftGo);
	rightStar();
		e = 0;
		startTask(TankDrive);
		startTask(liftGo);
            break;
         case    2:
            	startTask(pidclaw);
	stopTask(TankDrive);
		stopTask(liftGo);
	eight();
		e = 0;
		startTask(TankDrive);
		startTask(liftGo);
            break;
            case    3:
            	startTask(pidclaw);
	stopTask(TankDrive);
		stopTask(liftGo);
		hang();
		e = 0;
		startTask(TankDrive);
		startTask(liftGo);
            break;
        default:
  startTask(pidclaw);
	stopTask(TankDrive);
		stopTask(liftGo);

		e = 0;
		startTask(TankDrive);
		startTask(liftGo);

            break;
        }


        }

	//startTask(pidBase);
		//	stopTask(MotorSlewRateTask);


		//startTask(pidBase);

			//auton();
		//	stopTask(pidBase);
		//	startTask(MotorSlewRateTask);

		//stopTask(pidBase);
	//helper();
	//auton();
	//skills();

task usercontrol()
{
	// User control code here, inside the loop
 GyroInit();
	SensorFullCount[gyro] = 3600;
	SensorScale[gyro] = 70;
	SensorValue[gyro] = 0;
	stopTask(pidController);
	stopTask(pidclaw);
	stopTask(TankDrive);
		stopTask(liftGo);
	if(pidd == 2) {
		startTask( pidController );
		startTask(pidclaw);
		startTask(liftrip);
		  // Start motor slew rate control
    StartTask( MotorSlewRateTask );

    // Start driver control tasks
    StartTask( TankDrive );
    StartTask( liftGo );


	}
	int pneum = 0;


	while (true)
	{
		pidSensorCurrentValue = (4095 - SensorValue[potlift]);
	/**	leftj = speedSwag(VexRT[ch3]);
		rightj = speedSwag(VexRT[ch2]);
		motor[lBase2] = motor[lBase] = leftj;
		motor[rBase2] = motor[rBase] = rightj; **/
		/**motor[fR] = +VexRT[ch4] + VexRT[ch1] - VexRT[ch3];
		motor[fL]= + VexRT[ch4] + VexRT[ch1] + VexRT[ch3];
		motor[bL]= -VexRT[ch4] + VexRT[ch1] + VexRT[ch3];
		motor[bR] = -VexRT[ch4] + VexRT[ch1] - VexRT[ch3];**/
		int i =0;

		/**
		if(vexRT[Btn6U] ==1)
		{
		if (SensorValue[sol]== 1){
		SensorValue[sol] = 0;
		}
		else if (SensorValue[sol]== 0){
		SensorValue[sol] = 1;
		}
		wait1Msec(500);
		} **/
		/**


		**/

		if(vexRT[Btn7U] == 1) //Left Shoulder Lift Up
		{
			e = 1;
      z = 0;

		}
		if(vexRT[Btn7D] == 1){
			recorder();
		}


		/**if(vexRT[Btn8R] == 1) //Left Shoulder Lift Up
		{
		i = 1;
		}
		if(vexRT[Btn8U] == 1) //Left Shoulder Lift Up
		{
		motor[lights] = 0;
		}
		if(i==1){
		motor[lights] = 127;
		}
		**/

		if(vexRT[Btn8D] == 1 && vexRT[Btn8R] == 1) //Left Shoulder Lift Up
		{

			lowLim = 0;
			topLim = 3400;
			pid_Kp = 0.3;
			pidd = 1;

		}
		if(vexRT[Btn8D] == 1 && vexRT[Btn8R] == 1) //Left Shoulder Lift Up
		{
			stopTask(pidController);
			startTask(pidController);
		}
		else if(vexRT[Btn8U] == 1) //Left Shoulder Lift Up
		{

			lowLim = 100;
			topLim = 3100;
			pidd = 2;
			pid_Kp = 0.1;

		}
		/**else if(i==0){
		motor[lights] = 0;
		}**/
		/**if(vexRT[Btn7D] == 1) //Left Shoulder Lift Up
		{
		startTask(we);
		}**/


		if(vexRT[Btn8L] == 1) //Left Shoulder Lift Up
		{

		}

		/**		if(vexRT[Btn8R] == 1) //Left Shoulder Lift Up
		{
		debug();
		}**/

		wait1Msec(10);
	}
}
